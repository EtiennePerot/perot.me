Author: Etienne Perot
Website: https://perot.me/
Date: 2013-06-21 00:30:26

Daniel: As you have guessed, this means that the Linux driver for your device doesn't allow changing the MAC address (whereas the Windows one does). Unfortunately, there's not much you can do about it, other than patching the driver yourself or bugging Realtek about it. Trying other distributions may also help, in case you're using an old distribution with old drivers.

To answer your other questions:

The USB port you put it into doesn't matter. You can check it out by yourself by looking at the rule generated by `install-udev-rules.sh`, it should look like this:

    ACTION=="add", ATTR{address}=="00:11:22:33:44:55", RUN+="..."

This means: whenever udev sees a new device (`ACTION=="add"`), with this MAC address (`ATTR{address}=="00:11:22:33:44:55"`), then run this command (`RUN+="..."`). It doesn't depend on which port the device is placed in, it depends on the device's initial MAC address, which is why the `install-udev-rules.sh` script needed to collect it earlier.

The above explanation should answer your second answer as well. Since the `macchiato` command is run every time a device with this MAC address is plugged in, that means `macchiato` will run every time you plug the device in (the MAC address of your device will always be the hardware one when it is plugged in; it doesn't "remember" the spoofed MAC address once unplugged). Therefore, you do not need to reboot for MAC spoofing to occur. However, `macchiato` always picks a random MAC address when it runs; it doesn't remember that it assigned a particular MAC address to a particular device. That means that when you plug the device in, you will get a different MAC address than the one you had the previous time you plugged it in.

Here's a bonus tip: You can add a new udev rule to make it ignore `wlan0` completely, that way you don't accidentally use it sometime when you're not paying attention. To do this, create a udev rule that looks like this:

    SUBSYSTEM=="net", ATTR{address}=="66:77:88:99:aa:bb", OPTIONS+="ignore_device"

You can do some cool stuff like this with udev, such as [blocking known-bad hardware like mouse jigglers](https://github.com/ioerror/udev_antiforensics). Fun stuff.
